<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Label Cropper (v2)</title>
  <style>
    :root { font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif; }
    body { margin: 0; padding: 16px; background: #f7f7f9; }
    h1 { font-size: 20px; margin: 0 0 12px; }
    .card { background: #fff; border-radius: 12px; padding: 16px; box-shadow: 0 2px 10px rgba(0,0,0,.06); }
    .row { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 12px; }
    button,input[type="file"]::file-selector-button { font-size: 16px; padding: 10px 14px; border-radius: 10px; border: 1px solid #ddd; background: #fff; }
    button.primary { background: #0a84ff; color: white; border: none; }
    button:disabled { opacity: .5; }
    #log { font-size: 12px; color: #555; white-space: pre-wrap; }
    #preview { width: 100%; max-height: 60vh; border: 1px solid #e5e5ea; border-radius: 8px; background: #fff; display: block; }
    .hint { font-size: 12px; color:#666; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
  </style>
  <!-- PDF.js (render) -->
  <script src="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.min.js"></script>
  <script>pdfjsLib.GlobalWorkerOptions.workerSrc="https://cdn.jsdelivr.net/npm/pdfjs-dist@4.4.168/build/pdf.worker.min.js";</script>
  <!-- pdf-lib (edit crop box) -->
  <script src="https://cdn.jsdelivr.net/npm/pdf-lib@1.17.1/dist/pdf-lib.min.js"></script>
</head>
<body>
  <div class="card">
    <h1>Label Cropper (v2)</h1>
    <div class="row">
      <input id="file" type="file" accept="application/pdf">
      <button id="cropBtn" class="primary" disabled>Auto‑Crop</button>
      <button id="downloadBtn" disabled>Download</button>
      <button id="openBtn" disabled>Open / Print</button>
    </div>
    <div class="hint">Tip: Small, single‑page label PDFs should load in 1–3s. If it hangs, see messages below.</div>
  </div>

  <div style="height:12px"></div>
  <canvas id="preview"></canvas>
  <div id="log" class="mono"></div>

<script>
const fileInput = document.getElementById('file');
const cropBtn = document.getElementById('cropBtn');
const downloadBtn = document.getElementById('downloadBtn');
const openBtn = document.getElementById('openBtn');
const preview = document.getElementById('preview');
const log = document.getElementById('log');

let originalBytes = null;
let croppedBlob = null;

function info(msg){ log.textContent = msg; }
function add(msg){ log.textContent += "\\n" + msg; }

fileInput.addEventListener('change', async (e) => {
  const file = e.target.files?.[0];
  if(!file) return;
  info(`Selected: ${file.name} (${(file.size/1024).toFixed(0)} KB)`);
  add("Reading file...");
  try {
    const start = Date.now();
    originalBytes = await file.arrayBuffer();
    add(`Read in ${(Date.now()-start)} ms`);
    await renderFirstPage(originalBytes);
    cropBtn.disabled = false;
    downloadBtn.disabled = true;
    openBtn.disabled = true;
  } catch (err) {
    add("Error reading file: " + err);
  }
});

async function renderFirstPage(bytes, cropBox=null) {
  const t0 = Date.now();
  let timedOut = false;
  const timeout = new Promise((_, rej) => setTimeout(() => { timedOut = true; rej(new Error("Render timeout (10s)")); }, 10000));
  try {
    const pdfP = pdfjsLib.getDocument({data: bytes}).promise;
    const pdf = await Promise.race([pdfP, timeout]);
    const page = await Promise.race([pdf.getPage(1), timeout]);

    // Use a capped render size for speed
    const maxW = 1600;
    const view = page.getViewport({scale: 1.5});
    const scale = Math.min(1.5, maxW / view.width);
    const viewport = page.getViewport({ scale });
    const ctx = preview.getContext('2d');
    preview.width = viewport.width | 0;
    preview.height = viewport.height | 0;

    await Promise.race([page.render({ canvasContext: ctx, viewport }).promise, timeout]);
    add(`Rendered preview in ${(Date.now()-t0)} ms`);

    if (cropBox) {
      const { x, y, w, h } = cropBox;
      ctx.save();
      ctx.strokeStyle = '#0a84ff';
      ctx.lineWidth = 3;
      const rx = x * preview.width;
      const ry = (1 - (y + h)) * preview.height;
      const rw = w * preview.width;
      const rh = h * preview.height;
      ctx.strokeRect(rx, ry, rw, rh);
      ctx.restore();
    }
  } catch (err) {
    add("Preview error: " + err.message + (timedOut ? " (Try again; or we'll use a faster fallback when you press Auto‑Crop)" : ""));
  }
}

function findNonWhiteBBox(ctx, w, h, thresh=245) {
  const img = ctx.getImageData(0, 0, w, h).data;
  let minX=w, minY=h, maxX=0, maxY=0, found=false;
  for (let y=0; y<h; y++) {
    for (let x=0; x<w; x++) {
      const i = (y*w + x) * 4;
      const r=img[i], g=img[i+1], b=img[i+2];
      if (!(r>thresh && g>thresh && b>thresh)) {
        if (x<minX) minX=x; if (y<minY) minY=y;
        if (x>maxX) maxX=x; if (y>maxY) maxY=y;
        found=true;
      }
    }
  }
  if (!found) return null;
  return { x:minX, y:minY, w:maxX-minX, h:maxY-minY };
}

cropBtn.addEventListener('click', async () => {
  if(!originalBytes) return;
  info("Detecting content area…");
  let usedFallback = false;
  try {
    const pdf = await pdfjsLib.getDocument({data: originalBytes}).promise;
    const page = await pdf.getPage(1);

    // Fallback to smaller render if device struggles
    let scale = 1.5;
    let viewport = page.getViewport({ scale });
    if (viewport.width > 1800) {
      scale = 1.2;
      viewport = page.getViewport({ scale });
      usedFallback = true;
    }

    const tmp = document.createElement('canvas');
    tmp.width = viewport.width | 0;
    tmp.height = viewport.height | 0;
    const tctx = tmp.getContext('2d', { willReadFrequently: true });
    await page.render({ canvasContext: tctx, viewport }).promise;

    const box = findNonWhiteBBox(tctx, tmp.width, tmp.height);
    if (!box) { add("\\nCould not detect content; leaving as‑is."); return; }

    const nx = box.x / tmp.width;
    const nyTop = box.y / tmp.height;
    const nw = box.w / tmp.width;
    const nh = box.h / tmp.height;
    const ny = 1 - (nyTop + nh);
    const bbox = { x:nx, y:ny, w:nw, h:nh };

    add("Applying crop to all pages…");
    const pdfDoc = await PDFLib.PDFDocument.load(originalBytes);
    const pages = pdfDoc.getPages();
    const pad = 0.01;
    for (const p of pages) {
      const { width, height } = p.getSize();
      const left = Math.max(0, (bbox.x - pad) * width);
      const bottom = Math.max(0, (bbox.y - pad) * height);
      const right = Math.min(width, (bbox.x + bbox.w + pad) * width);
      const top = Math.min(height, (bbox.y + bbox.h + pad) * height);
      p.setCropBox(left, bottom, right - left, top - bottom);
      // p.setMediaBox(left, bottom, right - left, top - bottom);
    }
    const outBytes = await pdfDoc.save();
    croppedBlob = new Blob([outBytes], { type: "application/pdf" });
    await renderFirstPage(originalBytes, bbox);
    add("Done. Tap “Open / Print” to AirPrint, or Download.");
    if (usedFallback) add("\\n(Used faster fallback render for detection.)");
    downloadBtn.disabled = false;
    openBtn.disabled = false;
  } catch (e) {
    add("Crop error: " + e.message);
  }
});

downloadBtn.addEventListener('click', () => {
  if (!croppedBlob) return;
  const a = document.createElement('a');
  a.href = URL.createObjectURL(croppedBlob);
  a.download = 'label-cropped.pdf';
  document.body.appendChild(a);
  a.click();
  setTimeout(()=>URL.revokeObjectURL(a.href), 2000);
  a.remove();
});

openBtn.addEventListener('click', () => {
  if (!croppedBlob) return;
  const url = URL.createObjectURL(croppedBlob);
  window.open(url, '_blank'); // iOS: Share → Print
  setTimeout(()=>URL.revokeObjectURL(url), 30000);
});
</script>
</body>
</html>
